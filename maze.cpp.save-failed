/************************************************************
Sokoban project - Maze file
Copyright Florent DIEDLER
Date : 27/02/2016

Please do not remove this header, if you use this file !
************************************************************/

#include "maze.h"
#include "graphic.h"
#include "utils/console.h"
#include "utils/coord.h"
#include <fstream>
#include <iomanip>


Maze::Maze(const std::string& path)
    : m_lig(0), m_col(0), m_pos_player(0), m_dir_player(TOP), m_level_path(path)
{
}

Maze::~Maze()
{
}

bool Maze::init()
{
    bool res = this->_load(this->m_level_path);
    if (!res)
    {
        std::cerr << "Cannot load maze... Check file : " << this->m_level_path << std::endl;
        return false;
    }

    return res;
}

// Check if all boxes are on a goal
bool Maze::_isCompleted() const
{
    for (unsigned int i=0; i<this->m_pos_boxes.size(); ++i)
    {
        if (!this->isSquareBoxPlaced(this->m_pos_boxes[i]))
            return false;
    }
    return true;
}

// Check if we can push a box in a direction
// INPUT: position of the box to check, direction,
// OUTPUT : the position of the box after pushing
//      TRUE if all goes right otherwise FALSE
bool Maze::_canPushBox(unsigned short posBox, char dir, unsigned short& newPosBox) const
{
    // Check if this position is a box !
    if (!this->isSquareBox(posBox))
        return false;

    // Compute new position according to push direction
    newPosBox = Coord::getDirPos(posBox, dir);

    // Can we push the box ?
    return this->isSquareWalkable(newPosBox);
}

// Load a maze from a file (DO NOT TOUCH)
bool Maze::_load(const std::string& path)
{
    std::vector<unsigned short> tmpPosBoxes;
    std::ifstream ifs(path.c_str());
    if (ifs)
    {
        std::vector<std::string> lines;
        std::string line;
        while (std::getline(ifs, line))
        {
            lines.push_back(line);
            this->m_lig++;
            this->m_col = (this->m_col < line.size() ? line.size() : this->m_col);
        }
        ifs.close();

        if (this->m_col > NB_MAX_WIDTH || this->m_lig > NB_MAX_HEIGHT)
        {
            std::cerr << "Maze::load => Bad formatting in level data..." << std::endl;
            return false;
        }

        Coord::m_nb_col = this->m_col;
        for (unsigned int i=0; i<lines.size(); i++)
        {
            //LDebug << "Maze::load => Reading : " << lines[i];
            for (unsigned int j=0; j<this->m_col; j++)
            {
                if (j < lines[i].size())
                {
                    bool both = false;
                    unsigned short pos = Coord::coord1D(i, j);
                    unsigned char s = (unsigned char)(lines[i][j] - '0');

                    // Need to add a goal and a box ;)
                    if (s == SPRITE_BOX_PLACED)
                    {
                        both = true;
                    }

                    if (s == SPRITE_GOAL || both)
                    {
                        this->m_pos_goals.push_back(pos);
                    }
                    if (s == SPRITE_BOX || both)
                    {
                        tmpPosBoxes.push_back(pos);
                    }

                    // Assign player position
                    if (s == SPRITE_MARIO)
                    {
                        this->m_pos_player = pos;
                        //LDebug << "\tAdding player pos (" << pos << ")";
                        s = SPRITE_GROUND;
                    }

                    // Add this value in the field
                    this->m_field.push_back(s);
                }
                else
                {
                    // Here - Out of bound
                    this->m_field.push_back(SPRITE_GROUND);
                }
            }
        }

        // Copy box position
        this->m_pos_boxes.resize(tmpPosBoxes.size());
        for (unsigned int i=0; i<tmpPosBoxes.size(); ++i)
        {
            this->m_pos_boxes[i] = tmpPosBoxes[i];
        }

        return (this->m_pos_boxes.size() == this->m_pos_goals.size());
    }
    else
    {
        std::cerr << "Maze::load => File does not exist..." << std::endl;
    }

    return false;
}

bool Maze::updatePlayer(char dir)
{
    if (dir < 0 || dir > MAX_DIR)
    {
        std::cerr << "Maze::updatePlayer => Direction not correct... " << +dir << std::endl;
        return false;
    }

    int posTabBox=-1;
    unsigned short newPos=Coord::getDirPos(m_pos_player,dir);
    if(isSquareWalkable(newPos))
    {
        m_pos_player = Coord::getDirPos(m_pos_player,dir);
        return false;
    }
    if(isSquareBox(newPos))
    {
        for (int i=0; i<m_pos_boxes.size(); i++)
        {
            if (m_pos_boxes[i] == newPos )
            {
                posTabBox=i;
            }
        }
        unsigned short oldPos=newPos;
        newPos=Coord::getDirPos(oldPos,dir);

        if(_canPushBox(oldPos,dir,newPos))
        {

            if (m_field[newPos] == SPRITE_GOAL )
            {
                m_field[newPos] = SPRITE_BOX_PLACED;
                if (m_field[oldPos] == SPRITE_BOX_PLACED )
                    m_field[oldPos] = SPRITE_GOAL;
                else
                    m_field[oldPos] = SPRITE_GROUND;
            }
            else if (m_field[newPos] == SPRITE_GROUND )

            {
                m_field[newPos] = SPRITE_BOX;
                if (m_field[oldPos] == SPRITE_BOX_PLACED )
                    m_field[oldPos] = SPRITE_GOAL;
                else
                    m_field[oldPos] = SPRITE_GROUND;
            }

            m_pos_boxes[posTabBox] = newPos;
            //m_field[newPos] = SPRITE_BOX;
            m_pos_player = Coord::getDirPos(m_pos_player,dir);

        }
    }
    if(_isCompleted())
        return true;
    else
    {
        return false;
    }

}

// Display maze on screen with Allegro
void Maze::draw(const Graphic& g) const
{
    for(unsigned int i=0; i<this->getSize(); i++)
    {
        unsigned int l = 0, c = 0;
        Coord::coord2D(i, l, c);

        if (i == this->m_pos_player)
        {
            g.drawT(g.getSpritePlayer(this->m_dir_player), c, l);
        }
        else
        {
            g.drawT(g.getSprite(this->m_field[i]), c, l);
        }
    }
}

// DO NOT TOUCH !
// Overload function for displaying debug information
// about Maze class
std::ostream& operator << (std::ostream& O, const Maze& m)
{
    unsigned int l, c;
    int i = 0;
    Coord::coord2D(m.m_pos_player, l, c);
    O << "Player position " << m.m_pos_player << " (" << l << "," << c << ")" << std::endl;
    O << "Field Size " << +m.m_lig << " x " << +m.m_col << " = " << m.getSize() << std::endl;
    O << "Field Vector capacity : " << m.m_field.capacity() << std::endl;
    O << "Field array : " << std::endl << std::endl;
    for(unsigned int l=0; l<m.getSize(); l++)
    {
        if (l == m.m_pos_player) Console::getInstance()->setColor(_COLOR_YELLOW);
        else if (m.isSquareWall(l)) Console::getInstance()->setColor(_COLOR_PURPLE);
        else if (m.isSquareBoxPlaced(l) || m.isSquareGoal(l)) Console::getInstance()->setColor(_COLOR_GREEN);
        else if (m.isSquareBox(l)) Console::getInstance()->setColor(_COLOR_BLUE);
        else if (m.m_field[l] == SPRITE_DEADSQUARE) Console::getInstance()->setColor(_COLOR_RED);
        else Console::getInstance()->setColor(_COLOR_WHITE);

        O << std::setw(2) << +m.m_field[l] << " "; // + => print as "int"

        if ((l+1) % m.m_col == 0)
        {
            O << std::endl;
        }
    }
    Console::getInstance()->setColor(_COLOR_DEFAULT);

    O << std::endl;
    O << "Box position : " << std::endl;
    for (unsigned int i=0; i<m.m_pos_boxes.size(); i++)
    {
        Coord::coord2D(m.m_pos_boxes[i], l, c);
        O << "\t" << "Box #" << i << " => " << std::setw(3) << m.m_pos_boxes[i] << std::setw(2) << " (" << l << "," << c << ")" << std::endl;
    }

    O << std::endl;
    O << "Goal position : " << std::endl;
    for (const auto& goal : m.m_pos_goals)
    {
        unsigned int l, c;
        Coord::coord2D(goal, l, c);
        if (m.isSquareBoxPlaced(goal)) Console::getInstance()->setColor(_COLOR_GREEN);
        O << "\t" << "Goal #" << i << " => " << std::setw(3) << goal << std::setw(2) << " (" << l << "," << c << ")" << std::endl;
        if (m.isSquareBoxPlaced(goal)) Console::getInstance()->setColor(_COLOR_DEFAULT);
        i++;
    }

    return O;
}

bool Maze::brutForce()
{
    bool win = false;
    m_tabDir.push_back(0);
    pos_boxesSauv = m_pos_boxes;
    pos_goalsSauv = m_pos_goals;
    pos_playerSauv = m_pos_player;
    fieldSauv = m_field;
    int j=1;

    while(!win)
    {

        for(int i=0; i< m_tabDir.size(); i++)
        {
            win=updatePlayer(m_tabDir[i]);
        }
        m_pos_boxes=pos_boxesSauv;
        m_pos_goals=pos_goalsSauv;
        m_pos_player=pos_playerSauv;
        m_field=fieldSauv;

        if(!win)
        {
            m_tabDir[m_tabDir.size()-1]++;
            for(int i=m_tabDir.size()-1; i>0; i--)
            {
                if(m_tabDir[i]==4)
                {
                    m_tabDir[i]=0;
                    m_tabDir[i-1]++;
                }
            }
            if(m_tabDir.size()==1)
            {
                m_tabDir[0]++;
            }
            if(m_tabDir[0]==4)
            {
                m_tabDir[0]=0;
                m_tabDir.push_back(0);
            }
            for(int i=0; i<m_tabDir.size(); i++)
            {

                std::cout << m_tabDir[i] << " ";
            }
            j++;
            std::cout << " " << j<<"\n";
            //std::cout << std::endl;
        }
    }

    std::cout << "comb ";
    for(int i=0; i<m_tabDir.size(); i++)
    {
        std::cout << m_tabDir[i] << " , ";
    }
    std::cout << " comb" << std::endl;
    std::cout << "size" << m_tabDir.size() << " size" << std::endl;
    return true;
}

bool Maze::bfs()
{
    bool win = false;
    std::vector <SauvInfo> sauvegarde;
    sauvegarde.push_back(SauvInfo(m_pos_player, m_field, m_pos_boxes,-1,0));
    std::queue <SauvInfo> maFile;
    maFile.push(sauvegarde[0]);
    bool nouveauSave=true;
    int indicePred = 0;

    while(!win)
    {
        SauvInfo temp = maFile.front();
        maFile.pop();

        m_pos_boxes = temp.m_pos_boxes;
        m_pos_player = temp.m_pos_player;
        m_field = temp.m_field;

        for(int i = 0; i<4; i++)
        {
            win=updatePlayer(i);
            if(!win)
            {
                    for(int j=0; j< sauvegarde.size();j++)
                    {
                        if(sauvegarde[j].m_pos_player==m_pos_player && sauvegarde[j].m_pos_boxes==m_pos_boxes)
                        {
                            nouveauSave=false;
                        }
                    }
                    if(nouveauSave)
                    {
                        sauvegarde.push_back(SauvInfo(m_pos_player,m_field,m_pos_boxes,indicePred,i));
                        maFile.push(sauvegarde[sauvegarde.size()-1]);
                    }
                nouveauSave = true;

                m_pos_boxes = temp.m_pos_boxes;
                m_pos_player = temp.m_pos_player;
                m_field = temp.m_field;

               // std::cout << sauvegarde.size() << std::endl;
            }
            else if(win)
            {
                sauvegarde.push_back(SauvInfo(m_pos_player,m_field,m_pos_boxes,indicePred,i));
                maFile.push(sauvegarde[sauvegarde.size()-1]);

                m_pos_boxes = sauvegarde[0].m_pos_boxes;
                m_pos_player = sauvegarde[0].m_pos_player;
                m_field = sauvegarde[0].m_field;
                i=4;//permet de sortir du for et ne pas perdre le boleen win
            }
        }
        indicePred++;
    }
    std::cout << "WIN"<< std::endl;

    std::stack <unsigned short> tabDirEnvers;
    int j = sauvegarde.size()-1;
    while(sauvegarde[j].m_pred!=-1)
    {
        tabDirEnvers.push(sauvegarde[j].m_coupPred);
        j = sauvegarde[j].m_pred;
    }
    while(!tabDirEnvers.empty())
    {
        m_tabDir.push_back(tabDirEnvers.top());
        tabDirEnvers.pop();
    }


    std::cout << "comb ";
    for(int i=0; i<m_tabDir.size(); i++)
    {
        std::cout << m_tabDir[i] << " , ";
    }
    std::cout << " comb" << std::endl;
    std::cout << "size" << m_tabDir.size() << " size" << std::endl;
    std::cout << " nombre de sauvegarde " << sauvegarde.size() << "nombre de sauvgarde" << std::endl;

    return true;
}

bool Maze::dfs()
{
    bool win = false;
    std::vector <SauvInfo> sauvegarde;
    sauvegarde.push_back(SauvInfo(m_pos_player, m_field, m_pos_boxes,-1,0));
    std::stack <SauvInfo> maPile;
    maPile.push(sauvegarde[0]);
    bool nouveauSave=true;
    int indicePred = 0;
    int taillePile;


   while(!win)
    {
        if(taillePile == maPile.size())
        maPile.pop();

        SauvInfo temp = maPile.top();

        m_pos_boxes = temp.m_pos_boxes;
        m_pos_player = temp.m_pos_player;
        m_field = temp.m_field;

        for(int i = 0; i<4; i++)
        {
            win=updatePlayer(i);
            if(!win)
            {
                    taillePile = sauvegarde.size();
                    for(int j=0; j< sauvegarde.size();j++)
                    {
                        if(sauvegarde[j].m_pos_player==m_pos_player && sauvegarde[j].m_pos_boxes==m_pos_boxes)
                        {
                            nouveauSave=false;
                        }
                    }
                    if(nouveauSave)
                    {
                        sauvegarde.push_back(SauvInfo(m_pos_player,m_field,m_pos_boxes,indicePred,i));
                        maPile.push(sauvegarde[sauvegarde.size()-1]);
                    }
                nouveauSave = true;

                m_pos_boxes = temp.m_pos_boxes;
                m_pos_player = temp.m_pos_player;
                m_field = temp.m_field;

               // std::cout << sauvegarde.size() << std::endl;
            }
            else if(win)
            {
                sauvegarde.push_back(SauvInfo(m_pos_player,m_field,m_pos_boxes,indicePred,i));
                maPile.push(sauvegarde[sauvegarde.size()-1]);

                m_pos_boxes = sauvegarde[0].m_pos_boxes;
                m_pos_player = sauvegarde[0].m_pos_player;
                m_field = sauvegarde[0].m_field;
                i=4;//permet de sortir du for et ne pas perdre le boleen win
            }
        }
        indicePred++;
    }

    std::cout << "WIN"<< std::endl;
    std::stack <unsigned short> m_tabDirEnvers;
    int j = sauvegarde.size()-1;
    while(sauvegarde[j].m_pred!=-1)
    {
        m_tabDirEnvers.push(sauvegarde[j].m_coupPred);
        j = sauvegarde[j].m_pred;
    }
    while(!m_tabDirEnvers.empty())
    {
        m_tabDir.push_back(m_tabDirEnvers.top());
        m_tabDirEnvers.pop();
    }


    std::cout << "comb ";
    for(int i=0; i<m_tabDir.size(); i++)
    {
        std::cout << m_tabDir[i] << " , ";
    }
    std::cout << " comb" << std::endl;
    std::cout << "size" << m_tabDir.size() << " size" << std::endl;

return true;
}
